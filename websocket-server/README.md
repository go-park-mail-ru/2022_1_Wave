# sync_player

## Введение
Итак, репозиторий представляет собой websocket-сервер для поддержания синхронизации плеера
пользователей между различными устройствами. Состояние плеера для каждого пользователя
хранится в redis'е. Доступны различные обновления этого состояния. Основная идея состоит в том, 
что текущее положение плеера высчитывается исходя из предыдущего состояния и времени, когда
это состояние было установлено. 

### Состояние плеера представлено следующей структурой:
```json
{
  "track_id": 1,
  "from_is": "album",
  "from_is_id": 4,
  "on_pause": false,
  "last_sec_position": 64,
  "time_state_update": "2022-05-09T09:09:07+0000"
}
```

`from_is` показывает, откуда текущий трек. Его возможные значения: `album`, `playlist`,
`favorites` (возможны дополнения).

`from_is_id` показывает соответствующее id альбома, плейлиста или избранного

`on_pause` показывает, на паузе сейчас трек или нет

`last_sec_position` показывает последнее положение прокрутки плеера, при котором было последнее
обновление состояния

`time_state_update` формируется на стороне клиента и показывает время, в которое 
на стороне клиента произошло обновление состояния

### Возможные обновленмя состояния:

1) Включить новый трек:
```json
{
  "type_push_state": "new_track",
  "track_id": 2,
  "from_is": "playlist", // если не изменилось, можно не указывать
  "from_is_id": 2,  // также не указываем, если не изменилось
  "time_state_update": "2022-05-09T09:09:12+0000"
}
```
Это сообщение посылается, когда пользователь включает новый трек, либо он включается
самостоятельно, т.к. предыдущий трек закончился. Также во время первого подключения, 
когда на стороне сервера еще нет состояния плеера, требуется, чтобы клиент его отправил
именно этой командой. 

2) Поставить на паузу:
```json
{
  "type_push_state": "on_pause",
  "time_state_update": "2022-05-09T09:10:12+0000"
}
```
Опять же замечу, что `time_state_update` выставляется непосредственно в момент клика на 
кнопку паузы, чтобы обеспечить максимальную синхронизацию. А положение плеера (поле `last_sec_position`), на котором
трек поставился на паузу, сервер высчитает как разность предыдущего `time_state_update` и только что полученного.

3) Снять с паузы:
```json
{
  "type_push_state": "off_pause",
  "time_state_update": "2022-05-09T09:12:12+0000"
}
```

4) Промотка трека:
```json
{
  "type_push_state": "change_position",
  "last_sec_position": 84,
  "time_state_update": "2022-05-09T09:12:12+0000"
}
```
Соответственно эта команда отправляется клиентом, когда пользователь кликнул на перемотку 
трека.

Когда клиент отправляет сообщение на сервер с изменением состояния, оно также пересылается
всем остальным его устройствам в том же самом виде, в котором ее послало одно из устройств.
На стороне фронтенда же нужно будет высчитать разницу между текущим пользовательским 
временем и временем, которое находится в поле `time_state_update`.

Также есть пара сообщений, которые сервер может сам отправить клиенту:
1) В случае, если еще не хранится состояние плеера: 
```json
{
  "type_push_state": "no_track_state"
}
```

2) В случае невалидного формата:
```json
{
  "type_push_state": "invalid_format"
}
```

## Примерный сценарий использования

Допустим, пользователь впервые подключился к нашему серверу через свой браузер, и у него еще нет состояния
плеера. В таком случае при подключении websocket-соединения сервер сразу отправит ему
соответствующее сообщение:
```json
{
  "type_push_state": "no_track_state"
}
```
Далее будет валидна только команда о новом включенном треке. Допустим, клиент 
ее отправляет:
```json
{
  "type_push_state": "new_track",
  "track_id": 2,
  "from_is": "playlist",
  "from_is_id": 2,
  "time_state_update": "2022-05-09T09:09:12+0000"
}
```
На сервере это состояние сохранится в следующем виде:
```json
{
  "track_id": 2,
  "from_is": "playlist",
  "from_is_id": 3,
  "on_pause": false,
  "last_sec_position": 0,
  "time_state_update": "2022-05-09T09:09:12+0000"
}
```

То есть состояние такого: трек с `id = 2` из плейлиста с `id = 3` начал играть `2022-05-09T09:09:12+0000`

Через 10 секунд пользователь заходит на сайт с телефона, подключается к нашему 
websocket-серверу и ему отправляется текущее состояние. Он смотрит, что 
его текущее время и время в `time_state_update` отличаются на 10 секунд и положение 
прокрутки выставляется на `last_sec_position` + 10 сек, т.е. на 10 секунд.

Далее пусть через 5 секунд пользователь нажал на паузу на смартфоне. Обновление состояния отправилось 
на сервер: 
```json
{
  "type_push_state": "on_pause",
  "time_state_update": "2022-05-09T09:09:27+0000"
}
```
Сервер сохранит новое состояние у себя в базе и разошлет всем подключенным websocket'ам 
текущего клиента обновление состояния (то есть в данном случае сообщение отправится на браузер 
компьютера). 

И пусть это сообщение браузер пользователя получил спустя 2 секунды после реального нажатия 
на паузу. Клиентский код без труда сможет понять, что нужно поставить трек на паузу и 
сделать промотку на 2 секунды назад, т.к. `time_state_update` на 2 секунды меньше 
текущего времени пользователя. 


## Важное уточнение
Перед закрытием страницы необходимо будет послать сообщение с постановкой трека на паузу. Иначе мы никак не можем 
покрыть кейс, при котором у пользователя было одно устройство, он вкладку закрыл - но состояние плеера осталось не обновленным.
И тогда при повторном заходе получится ситуация, что состояние плеера на сервере такое, будто бедный трек проигрывался 10 часов подряд.


Эту проблему можно также решить, отсылая раз в 5 секунд состояние плеера, но это ломает основную идею того, что мы шлем 
исключительно обновления состояния, а не его текущее положение. Так что необходимо отловить событие закрытия вкладки