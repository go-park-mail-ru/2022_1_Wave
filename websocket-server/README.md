# sync_player

## Введение
Итак, репозиторий представляет собой websocket-сервер для поддержания синхронизации плеера
пользователей между различными устройствами. Состояние плеера для каждого пользователя
хранится в redis'е. Доступны различные обновления этого состояния. Основная идея состоит в том, 
что текущее положение плеера высчитывается исходя из предыдущего состояния и времени, когда
это состояние было установлено. 

### Состояние плеера представлено следующей структурой:
```json
{
  "tracks_queue": [5, 8, 14, 7],
  "queue_position": 0,
  "on_pause": false,
  "last_sec_position": 64,
  "time_state_update": 123181237
}
```

`tracks_queue` показывает id текущих треков в очереди воспроизведения

`queue_position` показывает, какой трек сейчас из очереди сейчас воспроизводится

`on_pause` показывает, на паузе сейчас трек или нет

`last_sec_position` показывает последнее положение прокрутки плеера, при котором было последнее
обновление состояния. Тип - float64

`time_state_update` формируется на стороне клиента и показывает время, в которое 
на стороне клиента произошло обновление состояния. Тип - unixtime 

Чтобы получить трек:
```json
{
  "type_push_state": "get_player_state"
}
```

### Возможные обновления состояния:

1) Добавить треки в очередь воспроизведения:
```json
{
  "type_push_state": "push_track",
  "data": {
    "tracks_queue": [2]
  }
}
```
Это сообщение посылается, когда пользователь добавляет в очередь воспроизведения новый трек, при этом
текущий воспроизводимый трек не меняется. В текущую очередь воспроизведения добавятся все треки из отосланных

2) Изменение очереди воспроизведения:
```json
{
  "type_push_state": "new_tracks_queue",
  "data": {
      "tracks_queue": [5, 8, 14, 7],
      "queue_position": 1,
      "time_state_update": 1234567
  }
}
```
Это сообщение посылается, когда пользователь полностью меняет очередь воспроизведения. Например, когда включает 
другой альбом. При этом мы предполагаем, что текущий воспроизводимый трек начинает воспроизводиться с самого начала.

3) Включить в очереди новый трек:
```json
{
  "type_push_state": "new_track",
  "data": {
    "queue_position": 2,
    "time_state_update": 1234567
  }
}
```
Это сообщение посылается при любой смене трека в очереди воспроизведения. С помощью кнопок "следующий", "предыдущий", 
либо просто потому что текущий трек закончил воспроизводиться, либо пользователь тыкнул на рандомный трек.
При этом мы предполагаем, что новый трек воспроизводится с самого начала, т.е. `last_sec_position` будет равен 0.

5) Поставить на паузу:
```json
{
  "type_push_state": "on_pause",
  "data": {
    "time_state_update": 1234567
  }
}
```
Опять же замечу, что `time_state_update` выставляется непосредственно в момент клика на 
кнопку паузы, чтобы обеспечить максимальную синхронизацию. А положение плеера (поле `last_sec_position`), на котором
трек поставился на паузу, сервер высчитает как разность предыдущего `time_state_update` и только что полученного.

6) Снять с паузы:
```json
{
  "type_push_state": "off_pause",
  "data": {
    "time_state_update": 1234567
  }
}
```

7) Промотка трека:
```json
{
  "type_push_state": "change_position",
  "last_sec_position": 84,
  "time_state_update": 1234567
}
```
Соответственно эта команда отправляется клиентом, когда пользователь кликнул на перемотку 
трека.

Когда клиент отправляет сообщение на сервер с изменением состояния, оно также пересылается
всем остальным его устройствам в том же самом виде, в котором ее послало одно из устройств.
На стороне фронтенда же нужно будет высчитать разницу между текущим пользовательским 
временем и временем, которое находится в поле `time_state_update`.

Также есть пара сообщений, которые сервер может сам отправить клиенту:
1) В случае, если еще не хранится состояние плеера: 
```json
{
  "type_push_state": "no_track_state"
}
```

2) В случае невалидного формата:
```json
{
  "type_push_state": "invalid_format"
}
```

## Примерный сценарий использования

Допустим, пользователь впервые подключился к нашему серверу через свой браузер, и у него еще нет состояния
плеера. В таком случае при подключении websocket-соединения сервер сразу отправит ему
соответствующее сообщение:
```json
{
  "type_push_state": "no_track_state"
}
```
Далее будет валидна только команда о новой очереди воспроизведения. Допустим, клиент 
ее отправляет:
```json
{
  "type_push_state": "new_tracks_queue",
  "tracks_queue": [5, 8, 14, 7],
  "queue_position": 0,
  "time_state_update": 1234567
}
```
На сервере это состояние сохранится в следующем виде:
```json
{
  "tracks_queue": [5, 8, 14, 7],
  "queue_position": 0,
  "on_pause": false,
  "last_sec_position": 0,
  "time_state_update": 1234567
}
```

То есть состояние такого: в очереди треков `[5, 8, 14, 7]` начал играть первый трек с `id=5` в `2022-05-09T09:09:12+0000`

Через 10 секунд пользователь заходит на сайт с телефона, подключается к нашему 
websocket-серверу и ему отправляется текущее состояние. Он смотрит, что 
его текущее время и время в `time_state_update` отличаются на 10 секунд и положение 
прокрутки выставляется на `last_sec_position` + 10 сек, т.е. на 10 секунд.

Далее пусть через 5 секунд пользователь нажал на паузу на смартфоне. Обновление состояния отправилось 
на сервер: 
```json
{
  "type_push_state": "on_pause",
  "time_state_update": 1234577
}
```
Сервер сохранит новое состояние у себя в базе и разошлет всем подключенным websocket'ам 
текущего клиента обновление состояния (то есть в данном случае сообщение отправится на браузер 
компьютера). 

И пусть это сообщение браузер пользователя получил спустя 2 секунды после реального нажатия 
на паузу. Клиентский код без труда сможет понять, что нужно поставить трек на паузу и 
сделать промотку на 2 секунды назад, т.к. `time_state_update` на 2 секунды меньше 
текущего времени пользователя.

Далее пользователь захотел добавить трек в очередь воспроизведения, и посылает соответствующую команду:
```json
{
  "type_push_state": "push_track",
  "tracks_queue": [2]
}
```
Это сообщение разошлется всем его устройствам, а состояние на сервере обновится до такого:
```json
{
  "tracks_queue": [5, 8, 14, 7, 2],
  "queue_position": 0, // не изменится
  "on_pause": false, // не изменится
  "last_sec_position": 0, // не изменится
  "time_state_update": 1234577 // не изменится
}
```


## Важное уточнение
Перед закрытием страницы необходимо будет послать сообщение с постановкой трека на паузу. Иначе мы никак не можем 
покрыть кейс, при котором у пользователя было одно устройство, он вкладку закрыл - но состояние плеера осталось не обновленным.
И тогда при повторном заходе получится ситуация, что состояние плеера на сервере такое, будто бедный трек проигрывался 10 часов подряд.


Эту проблему можно также решить, отсылая раз в 5 секунд состояние плеера, но это ломает основную идею того, что мы шлем 
исключительно обновления состояния, а не его текущее положение. Так что необходимо отловить событие закрытия вкладки